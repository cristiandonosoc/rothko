// This file is autogenerated. Do not modify it.

// Including import2ozz.cc file.

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) 2019 Guillaume Blanc                                         //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#include "ozz/animation/offline/tools/import2ozz.h"

#include <cstdlib>
#include <cstring>


// Includes internal include file animation/offline/tools/import2ozz_anim.h

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) 2019 Guillaume Blanc                                         //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#ifndef OZZ_ANIMATION_OFFLINE_TOOLS_IMPORT2OZZ_ANIM_H_
#define OZZ_ANIMATION_OFFLINE_TOOLS_IMPORT2OZZ_ANIM_H_

#include "ozz/base/endianness.h"
#include "ozz/base/platform.h"


// Includes internal include file animation/offline/tools/import2ozz_config.h

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) 2019 Guillaume Blanc                                         //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#ifndef OZZ_ANIMATION_OFFLINE_TOOLS_IMPORT2OZZ_CONFIG_H_
#define OZZ_ANIMATION_OFFLINE_TOOLS_IMPORT2OZZ_CONFIG_H_

#include "ozz/base/platform.h"

#include <json/json-forwards.h>

namespace ozz {
namespace animation {
namespace offline {

// Get the sanitized (all members are set, with the right types) configuration.
bool ProcessConfiguration(Json::Value* _config);

// Internal function used to compare enum names.
bool CompareName(const char* _a, const char* _b);

// Struct allowing inheriting class to provide enum names.
template <typename _Type, typename _Enum>
struct JsonEnum {
  // Struct allowing inheriting class to provide enum names.
  struct EnumNames {
    size_t count;
    const char** names;
  };

  static bool GetEnumFromName(const char* _name, _Enum* _enum) {
    const EnumNames enums = _Type::GetNames();
    for (size_t i = 0; i < enums.count; ++i) {
      if (CompareName(enums.names[i], _name)) {
        *_enum = static_cast<_Enum>(i);
        return true;
      }
    }
    return false;
  }

  static const char* GetEnumName(_Enum _enum) {
    const EnumNames enums = _Type::GetNames();
    assert(static_cast<size_t>(_enum) < enums.count);
    return enums.names[_enum];
  }

  static bool IsValidEnumName(const char* _name) {
    const EnumNames enums = _Type::GetNames();
    bool valid = false;
    for (size_t i = 0; !valid && i < enums.count; ++i) {
      valid = CompareName(enums.names[i], _name);
    }
    return valid;
  }
};

}  // namespace offline
}  // namespace animation
}  // namespace ozz
#endif  // OZZ_ANIMATION_OFFLINE_TOOLS_IMPORT2OZZ_CONFIG_H_

#include "ozz/animation/offline/tools/import2ozz.h"

namespace Json {
class Value;
}

namespace ozz {
namespace animation {
namespace offline {

class OzzImporter;
bool ImportAnimations(const Json::Value& _config, OzzImporter* _importer,
                      const ozz::Endianness _endianness);

// Additive reference enum to config string conversions.
struct AdditiveReferenceEnum {
  enum Value { kAnimation, kSkeleton };
};
struct AdditiveReference
    : JsonEnum<AdditiveReference, AdditiveReferenceEnum::Value> {
  static EnumNames GetNames();
};
}  // namespace offline
}  // namespace animation
}  // namespace ozz
#endif  // OZZ_ANIMATION_OFFLINE_TOOLS_IMPORT2OZZ_ANIM_H_


// Includes internal include file animation/offline/tools/import2ozz_config.h

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) 2019 Guillaume Blanc                                         //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#ifndef OZZ_ANIMATION_OFFLINE_TOOLS_IMPORT2OZZ_CONFIG_H_
#define OZZ_ANIMATION_OFFLINE_TOOLS_IMPORT2OZZ_CONFIG_H_

#include "ozz/base/platform.h"

#include <json/json-forwards.h>

namespace ozz {
namespace animation {
namespace offline {

// Get the sanitized (all members are set, with the right types) configuration.
bool ProcessConfiguration(Json::Value* _config);

// Internal function used to compare enum names.
bool CompareName(const char* _a, const char* _b);

// Struct allowing inheriting class to provide enum names.
template <typename _Type, typename _Enum>
struct JsonEnum {
  // Struct allowing inheriting class to provide enum names.
  struct EnumNames {
    size_t count;
    const char** names;
  };

  static bool GetEnumFromName(const char* _name, _Enum* _enum) {
    const EnumNames enums = _Type::GetNames();
    for (size_t i = 0; i < enums.count; ++i) {
      if (CompareName(enums.names[i], _name)) {
        *_enum = static_cast<_Enum>(i);
        return true;
      }
    }
    return false;
  }

  static const char* GetEnumName(_Enum _enum) {
    const EnumNames enums = _Type::GetNames();
    assert(static_cast<size_t>(_enum) < enums.count);
    return enums.names[_enum];
  }

  static bool IsValidEnumName(const char* _name) {
    const EnumNames enums = _Type::GetNames();
    bool valid = false;
    for (size_t i = 0; !valid && i < enums.count; ++i) {
      valid = CompareName(enums.names[i], _name);
    }
    return valid;
  }
};

}  // namespace offline
}  // namespace animation
}  // namespace ozz
#endif  // OZZ_ANIMATION_OFFLINE_TOOLS_IMPORT2OZZ_CONFIG_H_


// Includes internal include file animation/offline/tools/import2ozz_skel.h

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) 2019 Guillaume Blanc                                         //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#ifndef OZZ_ANIMATION_OFFLINE_TOOLS_IMPORT2OZZ_SKEL_H_
#define OZZ_ANIMATION_OFFLINE_TOOLS_IMPORT2OZZ_SKEL_H_

#include "ozz/base/endianness.h"
#include "ozz/base/platform.h"

namespace Json {
class Value;
}

namespace ozz {
namespace animation {
namespace offline {

class OzzImporter;

bool ImportSkeleton(const Json::Value& _config, OzzImporter* _importer,
                    const ozz::Endianness _endianness);

}  // namespace offline
}  // namespace animation
}  // namespace ozz
#endif  // OZZ_ANIMATION_OFFLINE_TOOLS_IMPORT2OZZ_SKEL_H_


#include "ozz/base/log.h"

#include "ozz/base/io/stream.h"

#include "ozz/options/options.h"

#include <json/json.h>

// Declares command line options.
OZZ_OPTIONS_DECLARE_STRING(file, "Specifies input file", "", true)

static bool ValidateEndianness(const ozz::options::Option& _option,
                               int /*_argc*/) {
  const ozz::options::StringOption& option =
      static_cast<const ozz::options::StringOption&>(_option);
  bool valid = std::strcmp(option.value(), "native") == 0 ||
               std::strcmp(option.value(), "little") == 0 ||
               std::strcmp(option.value(), "big") == 0;
  if (!valid) {
    ozz::log::Err() << "Invalid endianness option \"" << option << "\""
                    << std::endl;
  }
  return valid;
}

OZZ_OPTIONS_DECLARE_STRING_FN(
    endian,
    "Selects output endianness mode. Can be \"native\" (same as current "
    "platform), \"little\" or \"big\".",
    "native", false, &ValidateEndianness)

ozz::Endianness InitializeEndianness() {
  // Initializes output endianness from options.
  ozz::Endianness endianness = ozz::GetNativeEndianness();
  if (std::strcmp(OPTIONS_endian, "little") == 0) {
    endianness = ozz::kLittleEndian;
  } else if (std::strcmp(OPTIONS_endian, "big") == 0) {
    endianness = ozz::kBigEndian;
  }
  ozz::log::LogV() << (endianness == ozz::kLittleEndian ? "Little" : "Big")
                   << " endian output binary format selected." << std::endl;
  return endianness;
}

static bool ValidateLogLevel(const ozz::options::Option& _option,
                             int /*_argc*/) {
  const ozz::options::StringOption& option =
      static_cast<const ozz::options::StringOption&>(_option);
  bool valid = std::strcmp(option.value(), "verbose") == 0 ||
               std::strcmp(option.value(), "standard") == 0 ||
               std::strcmp(option.value(), "silent") == 0;
  if (!valid) {
    ozz::log::Err() << "Invalid log level option \"" << option << "\""
                    << std::endl;
  }
  return valid;
}

OZZ_OPTIONS_DECLARE_STRING_FN(
    log_level,
    "Selects log level. Can be \"silent\", \"standard\" or \"verbose\".",
    "standard", false, &ValidateLogLevel)

void InitializeLogLevel() {
  ozz::log::Level log_level = ozz::log::GetLevel();
  if (std::strcmp(OPTIONS_log_level, "silent") == 0) {
    log_level = ozz::log::kSilent;
  } else if (std::strcmp(OPTIONS_log_level, "standard") == 0) {
    log_level = ozz::log::kStandard;
  } else if (std::strcmp(OPTIONS_log_level, "verbose") == 0) {
    log_level = ozz::log::kVerbose;
  }
  ozz::log::SetLevel(log_level);
  ozz::log::LogV() << "Verbose log level activated." << std::endl;
}

namespace ozz {
namespace animation {
namespace offline {

int OzzImporter::operator()(int _argc, const char** _argv) {
  // Parses arguments.
  ozz::options::ParseResult parse_result = ozz::options::ParseCommandLine(
      _argc, _argv, "2.0",
      "Imports skeleton and animations from a file and converts it to ozz "
      "binary raw or runtime data format.");
  if (parse_result != ozz::options::kSuccess) {
    return parse_result == ozz::options::kExitSuccess ? EXIT_SUCCESS
                                                      : EXIT_FAILURE;
  }

  // Initialize general executable options.
  InitializeLogLevel();
  const ozz::Endianness endianness = InitializeEndianness();

  Json::Value config;
  if (!ProcessConfiguration(&config)) {
    // Specific error message are reported during configuration processing.
    return EXIT_FAILURE;
  }

  // Ensures file to import actually exist.
  if (!ozz::io::File::Exist(OPTIONS_file)) {
    ozz::log::Err() << "File \"" << OPTIONS_file << "\" doesn't exist."
                    << std::endl;
    return EXIT_FAILURE;
  }

  // Imports animations from the document.
  ozz::log::Log() << "Importing file \"" << OPTIONS_file << "\"" << std::endl;
  if (!Load(OPTIONS_file)) {
    ozz::log::Err() << "Failed to import file \"" << OPTIONS_file << "\"."
                    << std::endl;
    return EXIT_FAILURE;
  }

  // Handles skeleton import processing
  if (!ImportSkeleton(config, this, endianness)) {
    return EXIT_FAILURE;
  }

  // Handles animations import processing
  if (!ImportAnimations(config, this, endianness)) {
    return EXIT_FAILURE;
  }

  return EXIT_SUCCESS;
}

ozz::String::Std OzzImporter::BuildFilename(const char* _filename,
                                            const char* _data_name) const {
  ozz::String::Std output(_filename);

  for (size_t asterisk = output.find('*'); asterisk != std::string::npos;
       asterisk = output.find('*')) {
    output.replace(asterisk, 1, _data_name);
  }
  return output;
}
}  // namespace offline
}  // namespace animation
}  // namespace ozz

// Including import2ozz_anim.cc file.

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) 2019 Guillaume Blanc                                         //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#include "ozz/animation/offline/tools/import2ozz.h"

#include <cstdlib>
#include <cstring>


// Includes internal include file animation/offline/tools/import2ozz_anim.h

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) 2019 Guillaume Blanc                                         //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#ifndef OZZ_ANIMATION_OFFLINE_TOOLS_IMPORT2OZZ_ANIM_H_
#define OZZ_ANIMATION_OFFLINE_TOOLS_IMPORT2OZZ_ANIM_H_

#include "ozz/base/endianness.h"
#include "ozz/base/platform.h"


// Includes internal include file animation/offline/tools/import2ozz_config.h

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) 2019 Guillaume Blanc                                         //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#ifndef OZZ_ANIMATION_OFFLINE_TOOLS_IMPORT2OZZ_CONFIG_H_
#define OZZ_ANIMATION_OFFLINE_TOOLS_IMPORT2OZZ_CONFIG_H_

#include "ozz/base/platform.h"

#include <json/json-forwards.h>

namespace ozz {
namespace animation {
namespace offline {

// Get the sanitized (all members are set, with the right types) configuration.
bool ProcessConfiguration(Json::Value* _config);

// Internal function used to compare enum names.
bool CompareName(const char* _a, const char* _b);

// Struct allowing inheriting class to provide enum names.
template <typename _Type, typename _Enum>
struct JsonEnum {
  // Struct allowing inheriting class to provide enum names.
  struct EnumNames {
    size_t count;
    const char** names;
  };

  static bool GetEnumFromName(const char* _name, _Enum* _enum) {
    const EnumNames enums = _Type::GetNames();
    for (size_t i = 0; i < enums.count; ++i) {
      if (CompareName(enums.names[i], _name)) {
        *_enum = static_cast<_Enum>(i);
        return true;
      }
    }
    return false;
  }

  static const char* GetEnumName(_Enum _enum) {
    const EnumNames enums = _Type::GetNames();
    assert(static_cast<size_t>(_enum) < enums.count);
    return enums.names[_enum];
  }

  static bool IsValidEnumName(const char* _name) {
    const EnumNames enums = _Type::GetNames();
    bool valid = false;
    for (size_t i = 0; !valid && i < enums.count; ++i) {
      valid = CompareName(enums.names[i], _name);
    }
    return valid;
  }
};

}  // namespace offline
}  // namespace animation
}  // namespace ozz
#endif  // OZZ_ANIMATION_OFFLINE_TOOLS_IMPORT2OZZ_CONFIG_H_

#include "ozz/animation/offline/tools/import2ozz.h"

namespace Json {
class Value;
}

namespace ozz {
namespace animation {
namespace offline {

class OzzImporter;
bool ImportAnimations(const Json::Value& _config, OzzImporter* _importer,
                      const ozz::Endianness _endianness);

// Additive reference enum to config string conversions.
struct AdditiveReferenceEnum {
  enum Value { kAnimation, kSkeleton };
};
struct AdditiveReference
    : JsonEnum<AdditiveReference, AdditiveReferenceEnum::Value> {
  static EnumNames GetNames();
};
}  // namespace offline
}  // namespace animation
}  // namespace ozz
#endif  // OZZ_ANIMATION_OFFLINE_TOOLS_IMPORT2OZZ_ANIM_H_


// Includes internal include file animation/offline/tools/import2ozz_config.h

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) 2019 Guillaume Blanc                                         //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#ifndef OZZ_ANIMATION_OFFLINE_TOOLS_IMPORT2OZZ_CONFIG_H_
#define OZZ_ANIMATION_OFFLINE_TOOLS_IMPORT2OZZ_CONFIG_H_

#include "ozz/base/platform.h"

#include <json/json-forwards.h>

namespace ozz {
namespace animation {
namespace offline {

// Get the sanitized (all members are set, with the right types) configuration.
bool ProcessConfiguration(Json::Value* _config);

// Internal function used to compare enum names.
bool CompareName(const char* _a, const char* _b);

// Struct allowing inheriting class to provide enum names.
template <typename _Type, typename _Enum>
struct JsonEnum {
  // Struct allowing inheriting class to provide enum names.
  struct EnumNames {
    size_t count;
    const char** names;
  };

  static bool GetEnumFromName(const char* _name, _Enum* _enum) {
    const EnumNames enums = _Type::GetNames();
    for (size_t i = 0; i < enums.count; ++i) {
      if (CompareName(enums.names[i], _name)) {
        *_enum = static_cast<_Enum>(i);
        return true;
      }
    }
    return false;
  }

  static const char* GetEnumName(_Enum _enum) {
    const EnumNames enums = _Type::GetNames();
    assert(static_cast<size_t>(_enum) < enums.count);
    return enums.names[_enum];
  }

  static bool IsValidEnumName(const char* _name) {
    const EnumNames enums = _Type::GetNames();
    bool valid = false;
    for (size_t i = 0; !valid && i < enums.count; ++i) {
      valid = CompareName(enums.names[i], _name);
    }
    return valid;
  }
};

}  // namespace offline
}  // namespace animation
}  // namespace ozz
#endif  // OZZ_ANIMATION_OFFLINE_TOOLS_IMPORT2OZZ_CONFIG_H_


// Includes internal include file animation/offline/tools/import2ozz_track.h

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) 2019 Guillaume Blanc                                         //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#ifndef OZZ_ANIMATION_OFFLINE_TOOLS_IMPORT2OZZ_TRACK_H_
#define OZZ_ANIMATION_OFFLINE_TOOLS_IMPORT2OZZ_TRACK_H_

#include "ozz/base/endianness.h"
#include "ozz/base/platform.h"


// Includes internal include file animation/offline/tools/import2ozz_config.h

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) 2019 Guillaume Blanc                                         //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#ifndef OZZ_ANIMATION_OFFLINE_TOOLS_IMPORT2OZZ_CONFIG_H_
#define OZZ_ANIMATION_OFFLINE_TOOLS_IMPORT2OZZ_CONFIG_H_

#include "ozz/base/platform.h"

#include <json/json-forwards.h>

namespace ozz {
namespace animation {
namespace offline {

// Get the sanitized (all members are set, with the right types) configuration.
bool ProcessConfiguration(Json::Value* _config);

// Internal function used to compare enum names.
bool CompareName(const char* _a, const char* _b);

// Struct allowing inheriting class to provide enum names.
template <typename _Type, typename _Enum>
struct JsonEnum {
  // Struct allowing inheriting class to provide enum names.
  struct EnumNames {
    size_t count;
    const char** names;
  };

  static bool GetEnumFromName(const char* _name, _Enum* _enum) {
    const EnumNames enums = _Type::GetNames();
    for (size_t i = 0; i < enums.count; ++i) {
      if (CompareName(enums.names[i], _name)) {
        *_enum = static_cast<_Enum>(i);
        return true;
      }
    }
    return false;
  }

  static const char* GetEnumName(_Enum _enum) {
    const EnumNames enums = _Type::GetNames();
    assert(static_cast<size_t>(_enum) < enums.count);
    return enums.names[_enum];
  }

  static bool IsValidEnumName(const char* _name) {
    const EnumNames enums = _Type::GetNames();
    bool valid = false;
    for (size_t i = 0; !valid && i < enums.count; ++i) {
      valid = CompareName(enums.names[i], _name);
    }
    return valid;
  }
};

}  // namespace offline
}  // namespace animation
}  // namespace ozz
#endif  // OZZ_ANIMATION_OFFLINE_TOOLS_IMPORT2OZZ_CONFIG_H_

#include "ozz/animation/offline/tools/import2ozz.h"

namespace Json {
class Value;
}

namespace ozz {
namespace animation {
class Skeleton;
namespace offline {

class OzzImporter;
bool ProcessTracks(OzzImporter& _importer, const char* _animation_name,
                   const Skeleton& _skeleton, const Json::Value& _config,
                   const ozz::Endianness _endianness);

// Property type enum to config string conversions.
struct PropertyTypeConfig
    : JsonEnum<PropertyTypeConfig, OzzImporter::NodeProperty::Type> {
  static EnumNames GetNames();
};
}  // namespace offline
}  // namespace animation
}  // namespace ozz
#endif  // OZZ_ANIMATION_OFFLINE_TOOLS_IMPORT2OZZ_TRACK_H_


#include "ozz/animation/offline/additive_animation_builder.h"
#include "ozz/animation/offline/animation_builder.h"
#include "ozz/animation/offline/animation_optimizer.h"
#include "ozz/animation/offline/raw_animation.h"
#include "ozz/animation/offline/raw_skeleton.h"
#include "ozz/animation/offline/skeleton_builder.h"

#include "ozz/animation/runtime/animation.h"
#include "ozz/animation/runtime/skeleton.h"

#include "ozz/base/io/archive.h"
#include "ozz/base/io/stream.h"

#include "ozz/base/maths/soa_transform.h"

#include "ozz/base/log.h"

#include "ozz/options/options.h"

#include <json/json.h>

namespace ozz {
namespace animation {
namespace offline {
namespace {

void DisplaysOptimizationstatistics(const RawAnimation& _non_optimized,
                                    const RawAnimation& _optimized) {
  size_t opt_translations = 0, opt_rotations = 0, opt_scales = 0;
  for (size_t i = 0; i < _optimized.tracks.size(); ++i) {
    const RawAnimation::JointTrack& track = _optimized.tracks[i];
    opt_translations += track.translations.size();
    opt_rotations += track.rotations.size();
    opt_scales += track.scales.size();
  }
  size_t non_opt_translations = 0, non_opt_rotations = 0, non_opt_scales = 0;
  for (size_t i = 0; i < _non_optimized.tracks.size(); ++i) {
    const RawAnimation::JointTrack& track = _non_optimized.tracks[i];
    non_opt_translations += track.translations.size();
    non_opt_rotations += track.rotations.size();
    non_opt_scales += track.scales.size();
  }

  // Computes optimization ratios.
  float translation_ratio =
      non_opt_translations != 0
          ? 100.f * opt_translations / non_opt_translations
          : 0;
  float rotation_ratio =
      non_opt_rotations != 0 ? 100.f * opt_rotations / non_opt_rotations : 0;
  float scale_ratio =
      non_opt_scales != 0 ? 100.f * opt_scales / non_opt_scales : 0;

  ozz::log::LogV() << "Optimization stage results (% of remaining keys):"
                   << std::endl;
  ozz::log::LogV() << " - Translations: " << translation_ratio << "%"
                   << std::endl;
  ozz::log::LogV() << " - Rotations: " << rotation_ratio << "%" << std::endl;
  ozz::log::LogV() << " - Scales: " << scale_ratio << "%" << std::endl;
}

Skeleton* LoadSkeleton(const char* _path) {
  // Reads the skeleton from the binary ozz stream.
  Skeleton* skeleton = NULL;
  {
    if (*_path == 0) {
      ozz::log::Err() << "Missing input skeleton file from json config."
                      << std::endl;
      return NULL;
    }
    ozz::log::LogV() << "Opens input skeleton ozz binary file: " << _path
                     << std::endl;
    ozz::io::File file(_path, "rb");
    if (!file.opened()) {
      ozz::log::Err() << "Failed to open input skeleton ozz binary file: \""
                      << _path << "\"" << std::endl;
      return NULL;
    }
    ozz::io::IArchive archive(&file);

    // File could contain a RawSkeleton or a Skeleton.
    if (archive.TestTag<RawSkeleton>()) {
      ozz::log::LogV() << "Reading RawSkeleton from file." << std::endl;

      // Reading the skeleton cannot file.
      RawSkeleton raw_skeleton;
      archive >> raw_skeleton;

      // Builds runtime skeleton.
      ozz::log::LogV() << "Builds runtime skeleton." << std::endl;
      SkeletonBuilder builder;
      skeleton = builder(raw_skeleton);
      if (!skeleton) {
        ozz::log::Err() << "Failed to build runtime skeleton." << std::endl;
        return NULL;
      }
    } else if (archive.TestTag<Skeleton>()) {
      // Reads input archive to the runtime skeleton.
      // This operation cannot fail.
      skeleton = ozz::memory::default_allocator()->New<Skeleton>();
      archive >> *skeleton;
    } else {
      ozz::log::Err() << "Failed to read input skeleton from binary file: "
                      << _path << std::endl;
      return NULL;
    }
  }
  return skeleton;
}

Vector<math::Transform>::Std SkeletonBindPoseSoAToAoS(
    const Skeleton& _skeleton) {
  // Copy skeleton bind pose to AoS form.
  Vector<math::Transform>::Std transforms(_skeleton.num_joints());
  for (int i = 0; i < _skeleton.num_soa_joints(); ++i) {
    const math::SoaTransform& soa_transform = _skeleton.joint_bind_poses()[i];
    math::SimdFloat4 translation[4];
    math::SimdFloat4 rotation[4];
    math::SimdFloat4 scale[4];
    math::Transpose3x4(&soa_transform.translation.x, translation);
    math::Transpose4x4(&soa_transform.rotation.x, rotation);
    math::Transpose3x4(&soa_transform.scale.x, scale);
    for (int j = 0; j < 4 && i * 4 + j < _skeleton.num_joints(); ++j) {
      math::Transform& out = transforms[i * 4 + j];
      math::Store3PtrU(translation[j], &out.translation.x);
      math::StorePtrU(rotation[j], &out.rotation.x);
      math::Store3PtrU(scale[j], &out.scale.x);
    }
  }
  return transforms;
}

bool Export(OzzImporter& _importer, const RawAnimation& _raw_animation,
            const Skeleton& _skeleton, const Json::Value& _config,
            const ozz::Endianness _endianness) {
  // Raw animation to build and output.
  RawAnimation raw_animation;

  // Make delta animation if requested.
  if (_config["additive"].asBool()) {
    ozz::log::Log() << "Makes additive animation." << std::endl;

    AdditiveAnimationBuilder additive_builder;
    RawAnimation raw_additive;

    AdditiveReferenceEnum::Value reference;
    bool enum_found = AdditiveReference::GetEnumFromName(
        _config["additive_reference"].asCString(), &reference);
    assert(enum_found);  // Already checked on config side.

    bool succeeded = false;
    if (enum_found && reference == AdditiveReferenceEnum::kSkeleton) {
      const Vector<math::Transform>::Std transforms =
          SkeletonBindPoseSoAToAoS(_skeleton);
      succeeded = additive_builder(_raw_animation, make_range(transforms),
                                   &raw_additive);
    } else {
      succeeded = additive_builder(_raw_animation, &raw_additive);
    }

    if (!succeeded) {
      ozz::log::Err() << "Failed to make additive animation." << std::endl;
      return false;
    }

    // Now use additive animation.
    raw_animation = raw_additive;
  } else {
    raw_animation = _raw_animation;
  }

  // Optimizes animation if option is enabled.
  if (_config["optimize"].asBool()) {
    ozz::log::Log() << "Optimizing animation." << std::endl;
    AnimationOptimizer optimizer;

    // Setup optimizer from config parameters.
    const Json::Value& tolerances = _config["optimization_tolerances"];
    optimizer.translation_tolerance = tolerances["translation"].asFloat();
    optimizer.rotation_tolerance = tolerances["rotation"].asFloat();
    optimizer.scale_tolerance = tolerances["scale"].asFloat();
    optimizer.hierarchical_tolerance = tolerances["hierarchical"].asFloat();

    RawAnimation raw_optimized_animation;
    if (!optimizer(raw_animation, _skeleton, &raw_optimized_animation)) {
      ozz::log::Err() << "Failed to optimize animation." << std::endl;
      return false;
    }

    // Displays optimization statistics.
    DisplaysOptimizationstatistics(raw_animation, raw_optimized_animation);

    // Brings data back to the raw animation.
    raw_animation = raw_optimized_animation;
  }

  // Builds runtime animation.
  Animation* animation = NULL;
  if (!_config["raw"].asBool()) {
    ozz::log::Log() << "Builds runtime animation." << std::endl;
    AnimationBuilder builder;
    animation = builder(raw_animation);
    if (!animation) {
      ozz::log::Err() << "Failed to build runtime animation." << std::endl;
      return false;
    }
  }

  {
    // Prepares output stream. File is a RAII so it will close automatically
    // at the end of this scope. Once the file is opened, nothing should fail
    // as it would leave an invalid file on the disk.

    // Builds output filename.
    ozz::String::Std filename = _importer.BuildFilename(
        _config["filename"].asCString(), _raw_animation.name.c_str());

    ozz::log::LogV() << "Opens output file: " << filename << std::endl;
    ozz::io::File file(filename.c_str(), "wb");
    if (!file.opened()) {
      ozz::log::Err() << "Failed to open output file: \"" << filename << "\""
                      << std::endl;
      ozz::memory::default_allocator()->Delete(animation);
      return false;
    }

    // Initializes output archive.
    ozz::io::OArchive archive(&file, _endianness);

    // Fills output archive with the animation.
    if (_config["raw"].asBool()) {
      ozz::log::Log() << "Outputs RawAnimation to binary archive." << std::endl;
      archive << raw_animation;
    } else {
      ozz::log::LogV() << "Outputs Animation to binary archive." << std::endl;
      archive << *animation;
    }
  }

  ozz::log::LogV() << "Animation binary archive successfully outputted."
                   << std::endl;

  // Delete local objects.
  ozz::memory::default_allocator()->Delete(animation);

  return true;
}  // namespace

bool ProcessAnimation(OzzImporter& _importer, const char* _animation_name,
                      const Skeleton& _skeleton, const Json::Value& _config,
                      const ozz::Endianness _endianness) {
  RawAnimation animation;
  if (!_importer.Import(_animation_name, _skeleton,
                        _config["sampling_rate"].asFloat(), &animation)) {
    ozz::log::Err() << "Failed to import animation \"" << _animation_name
                    << "\"" << std::endl;
    return false;
  } else {
    // Give animation a name
    animation.name = _animation_name;

    return Export(_importer, animation, _skeleton, _config, _endianness);
  }
}
}  // namespace

AdditiveReference::EnumNames AdditiveReference::GetNames() {
  static const char* kNames[] = {"animation", "skeleton"};
  const EnumNames enum_names = {OZZ_ARRAY_SIZE(kNames), kNames};
  return enum_names;
}

bool ImportAnimations(const Json::Value& _config, OzzImporter* _importer,
                      const ozz::Endianness _endianness) {
  const Json::Value& skeleton_config = _config["skeleton"];
  const Json::Value& animations_config = _config["animations"];

  if (animations_config.size() == 0) {
    ozz::log::Log() << "Configuration contains no animation import "
                       "definition, animations import will be skipped."
                    << std::endl;
    return true;
  }

  // Get all available animation names.
  const OzzImporter::AnimationNames& import_animation_names =
      _importer->GetAnimationNames();

  // Are there animations available
  if (import_animation_names.empty()) {
    ozz::log::Err() << "No animation found." << std::endl;
    return true;
  }

  // Iterates all imported animations, build and output them.
  bool success = true;

  // Import skeleton instance.
  Skeleton* skeleton = LoadSkeleton(skeleton_config["filename"].asCString());
  success &= skeleton != NULL;

  // Loop though all existing animations, and export those who match
  // configuration.
  for (Json::ArrayIndex i = 0; success && i < animations_config.size(); ++i) {
    const Json::Value& animation_config = animations_config[i];
    const char* clip_match = animation_config["clip"].asCString();

    if (*clip_match == 0) {
      ozz::log::Log() << "No clip name provided. Animation import "
                         "will be skipped."
                      << std::endl;
      continue;
    }

    bool matched = false;
    for (size_t j = 0; success && j < import_animation_names.size(); ++j) {
      const char* animation_name = import_animation_names[j].c_str();
      if (!strmatch(animation_name, clip_match)) {
        continue;
      }

      matched = true;
      success = ProcessAnimation(*_importer, animation_name, *skeleton,
                                 animation_config, _endianness);

      const Json::Value& tracks_config = animation_config["tracks"];
      for (Json::ArrayIndex t = 0; success && t < tracks_config.size(); ++t) {
        success = ProcessTracks(*_importer, animation_name, *skeleton,
                                tracks_config[t], _endianness);
      }
    }
    // Don't display any message if no animation is supposed to be imported.
    if (!matched && *clip_match != 0) {
      ozz::log::Log() << "No matching animation found for \"" << clip_match
                      << "\"." << std::endl;
    }
  }

  ozz::memory::default_allocator()->Delete(skeleton);

  return success;
}
}  // namespace offline
}  // namespace animation
}  // namespace ozz

// Including import2ozz_config.cc file.

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) 2019 Guillaume Blanc                                         //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//


// Includes internal include file animation/offline/tools/import2ozz_config.h

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) 2019 Guillaume Blanc                                         //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#ifndef OZZ_ANIMATION_OFFLINE_TOOLS_IMPORT2OZZ_CONFIG_H_
#define OZZ_ANIMATION_OFFLINE_TOOLS_IMPORT2OZZ_CONFIG_H_

#include "ozz/base/platform.h"

#include <json/json-forwards.h>

namespace ozz {
namespace animation {
namespace offline {

// Get the sanitized (all members are set, with the right types) configuration.
bool ProcessConfiguration(Json::Value* _config);

// Internal function used to compare enum names.
bool CompareName(const char* _a, const char* _b);

// Struct allowing inheriting class to provide enum names.
template <typename _Type, typename _Enum>
struct JsonEnum {
  // Struct allowing inheriting class to provide enum names.
  struct EnumNames {
    size_t count;
    const char** names;
  };

  static bool GetEnumFromName(const char* _name, _Enum* _enum) {
    const EnumNames enums = _Type::GetNames();
    for (size_t i = 0; i < enums.count; ++i) {
      if (CompareName(enums.names[i], _name)) {
        *_enum = static_cast<_Enum>(i);
        return true;
      }
    }
    return false;
  }

  static const char* GetEnumName(_Enum _enum) {
    const EnumNames enums = _Type::GetNames();
    assert(static_cast<size_t>(_enum) < enums.count);
    return enums.names[_enum];
  }

  static bool IsValidEnumName(const char* _name) {
    const EnumNames enums = _Type::GetNames();
    bool valid = false;
    for (size_t i = 0; !valid && i < enums.count; ++i) {
      valid = CompareName(enums.names[i], _name);
    }
    return valid;
  }
};

}  // namespace offline
}  // namespace animation
}  // namespace ozz
#endif  // OZZ_ANIMATION_OFFLINE_TOOLS_IMPORT2OZZ_CONFIG_H_


#include <cstring>
#include <fstream>
#include <sstream>


// Includes internal include file animation/offline/tools/import2ozz_anim.h

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) 2019 Guillaume Blanc                                         //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#ifndef OZZ_ANIMATION_OFFLINE_TOOLS_IMPORT2OZZ_ANIM_H_
#define OZZ_ANIMATION_OFFLINE_TOOLS_IMPORT2OZZ_ANIM_H_

#include "ozz/base/endianness.h"
#include "ozz/base/platform.h"


// Includes internal include file animation/offline/tools/import2ozz_config.h

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) 2019 Guillaume Blanc                                         //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#ifndef OZZ_ANIMATION_OFFLINE_TOOLS_IMPORT2OZZ_CONFIG_H_
#define OZZ_ANIMATION_OFFLINE_TOOLS_IMPORT2OZZ_CONFIG_H_

#include "ozz/base/platform.h"

#include <json/json-forwards.h>

namespace ozz {
namespace animation {
namespace offline {

// Get the sanitized (all members are set, with the right types) configuration.
bool ProcessConfiguration(Json::Value* _config);

// Internal function used to compare enum names.
bool CompareName(const char* _a, const char* _b);

// Struct allowing inheriting class to provide enum names.
template <typename _Type, typename _Enum>
struct JsonEnum {
  // Struct allowing inheriting class to provide enum names.
  struct EnumNames {
    size_t count;
    const char** names;
  };

  static bool GetEnumFromName(const char* _name, _Enum* _enum) {
    const EnumNames enums = _Type::GetNames();
    for (size_t i = 0; i < enums.count; ++i) {
      if (CompareName(enums.names[i], _name)) {
        *_enum = static_cast<_Enum>(i);
        return true;
      }
    }
    return false;
  }

  static const char* GetEnumName(_Enum _enum) {
    const EnumNames enums = _Type::GetNames();
    assert(static_cast<size_t>(_enum) < enums.count);
    return enums.names[_enum];
  }

  static bool IsValidEnumName(const char* _name) {
    const EnumNames enums = _Type::GetNames();
    bool valid = false;
    for (size_t i = 0; !valid && i < enums.count; ++i) {
      valid = CompareName(enums.names[i], _name);
    }
    return valid;
  }
};

}  // namespace offline
}  // namespace animation
}  // namespace ozz
#endif  // OZZ_ANIMATION_OFFLINE_TOOLS_IMPORT2OZZ_CONFIG_H_

#include "ozz/animation/offline/tools/import2ozz.h"

namespace Json {
class Value;
}

namespace ozz {
namespace animation {
namespace offline {

class OzzImporter;
bool ImportAnimations(const Json::Value& _config, OzzImporter* _importer,
                      const ozz::Endianness _endianness);

// Additive reference enum to config string conversions.
struct AdditiveReferenceEnum {
  enum Value { kAnimation, kSkeleton };
};
struct AdditiveReference
    : JsonEnum<AdditiveReference, AdditiveReferenceEnum::Value> {
  static EnumNames GetNames();
};
}  // namespace offline
}  // namespace animation
}  // namespace ozz
#endif  // OZZ_ANIMATION_OFFLINE_TOOLS_IMPORT2OZZ_ANIM_H_


// Includes internal include file animation/offline/tools/import2ozz_track.h

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) 2019 Guillaume Blanc                                         //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#ifndef OZZ_ANIMATION_OFFLINE_TOOLS_IMPORT2OZZ_TRACK_H_
#define OZZ_ANIMATION_OFFLINE_TOOLS_IMPORT2OZZ_TRACK_H_

#include "ozz/base/endianness.h"
#include "ozz/base/platform.h"


// Includes internal include file animation/offline/tools/import2ozz_config.h

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) 2019 Guillaume Blanc                                         //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#ifndef OZZ_ANIMATION_OFFLINE_TOOLS_IMPORT2OZZ_CONFIG_H_
#define OZZ_ANIMATION_OFFLINE_TOOLS_IMPORT2OZZ_CONFIG_H_

#include "ozz/base/platform.h"

#include <json/json-forwards.h>

namespace ozz {
namespace animation {
namespace offline {

// Get the sanitized (all members are set, with the right types) configuration.
bool ProcessConfiguration(Json::Value* _config);

// Internal function used to compare enum names.
bool CompareName(const char* _a, const char* _b);

// Struct allowing inheriting class to provide enum names.
template <typename _Type, typename _Enum>
struct JsonEnum {
  // Struct allowing inheriting class to provide enum names.
  struct EnumNames {
    size_t count;
    const char** names;
  };

  static bool GetEnumFromName(const char* _name, _Enum* _enum) {
    const EnumNames enums = _Type::GetNames();
    for (size_t i = 0; i < enums.count; ++i) {
      if (CompareName(enums.names[i], _name)) {
        *_enum = static_cast<_Enum>(i);
        return true;
      }
    }
    return false;
  }

  static const char* GetEnumName(_Enum _enum) {
    const EnumNames enums = _Type::GetNames();
    assert(static_cast<size_t>(_enum) < enums.count);
    return enums.names[_enum];
  }

  static bool IsValidEnumName(const char* _name) {
    const EnumNames enums = _Type::GetNames();
    bool valid = false;
    for (size_t i = 0; !valid && i < enums.count; ++i) {
      valid = CompareName(enums.names[i], _name);
    }
    return valid;
  }
};

}  // namespace offline
}  // namespace animation
}  // namespace ozz
#endif  // OZZ_ANIMATION_OFFLINE_TOOLS_IMPORT2OZZ_CONFIG_H_

#include "ozz/animation/offline/tools/import2ozz.h"

namespace Json {
class Value;
}

namespace ozz {
namespace animation {
class Skeleton;
namespace offline {

class OzzImporter;
bool ProcessTracks(OzzImporter& _importer, const char* _animation_name,
                   const Skeleton& _skeleton, const Json::Value& _config,
                   const ozz::Endianness _endianness);

// Property type enum to config string conversions.
struct PropertyTypeConfig
    : JsonEnum<PropertyTypeConfig, OzzImporter::NodeProperty::Type> {
  static EnumNames GetNames();
};
}  // namespace offline
}  // namespace animation
}  // namespace ozz
#endif  // OZZ_ANIMATION_OFFLINE_TOOLS_IMPORT2OZZ_TRACK_H_

#include "ozz/animation/offline/tools/import2ozz.h"

#include "ozz/animation/offline/animation_optimizer.h"
#include "ozz/animation/offline/track_optimizer.h"

#include "ozz/base/containers/string.h"
#include "ozz/base/log.h"

#include "ozz/options/options.h"

#include <json/json.h>

bool ValidateExclusiveConfigOption(const ozz::options::Option& _option,
                                   int _argc);
OZZ_OPTIONS_DECLARE_STRING_FN(
    config, "Specifies input configuration string in json format", "", false,
    &ValidateExclusiveConfigOption)
OZZ_OPTIONS_DECLARE_STRING_FN(
    config_file, "Specifies input configuration file in json format", "", false,
    &ValidateExclusiveConfigOption)

// Validate exclusive config options.
bool ValidateExclusiveConfigOption(const ozz::options::Option& _option,
                                   int _argc) {
  (void)_option;
  (void)_argc;
  bool not_exclusive =
      OPTIONS_config_file.value()[0] != 0 && OPTIONS_config.value()[0] != 0;
  if (not_exclusive) {
    ozz::log::Err() << "--config and --config_file are exclusive options."
                    << std::endl;
  }
  return !not_exclusive;
}

OZZ_OPTIONS_DECLARE_STRING(
    config_dump_reference,
    "Dumps reference json configuration to specified file.", "", false)

namespace ozz {
namespace animation {
namespace offline {
namespace {

template <typename _Type>
struct ToJsonType;

template <>
struct ToJsonType<int> {
  static Json::ValueType type() { return Json::intValue; }
};
template <>
struct ToJsonType<unsigned int> {
  static Json::ValueType type() { return Json::uintValue; }
};
template <>
struct ToJsonType<float> {
  static Json::ValueType type() { return Json::realValue; }
};
template <>
struct ToJsonType<const char*> {
  static Json::ValueType type() { return Json::stringValue; }
};
template <>
struct ToJsonType<bool> {
  static Json::ValueType type() { return Json::booleanValue; }
};

const char* JsonTypeToString(Json::ValueType _type) {
  switch (_type) {
    case Json::nullValue:
      return "null";
    case Json::intValue:
      return "integer";
    case Json::uintValue:
      return "unsigned integer";
    case Json::realValue:
      return "float";
    case Json::stringValue:
      return "UTF-8 string";
    case Json::booleanValue:
      return "boolean";
    case Json::arrayValue:
      return "array";
    case Json::objectValue:
      return "object";
    default:
      assert(false && "unknown json type");
      return "unknown";
  }
}

bool IsCompatibleType(Json::ValueType _type, Json::ValueType _expected) {
  switch (_expected) {
    case Json::nullValue:
      return _type == Json::nullValue;
    case Json::intValue:
      return _type == Json::intValue || _type == Json::uintValue;
    case Json::uintValue:
      return _type == Json::uintValue;
    case Json::realValue:
      return _type == Json::realValue || _type == Json::intValue ||
             _type == Json::uintValue;
    case Json::stringValue:
      return _type == Json::stringValue;
    case Json::booleanValue:
      return _type == Json::booleanValue;
    case Json::arrayValue:
      return _type == Json::arrayValue;
    case Json::objectValue:
      return _type == Json::objectValue;
    default:
      assert(false && "unknown json type");
      return false;
  }
}

bool MakeDefaultArray(Json::Value& _parent, const char* _name,
                      const char* _comment, bool _empty) {
  // Check if exists first.
  const bool existed = _parent.isMember(_name);
  // Create in any case
  Json::Value* member = &_parent[_name];
  if (!existed) {
    member->resize(_empty ? 0 : 1);
    assert(member->isArray());
  }

  // Pushes comment if there's not one already.
  if (*_comment != 0 && !member->hasComment(Json::commentBefore)) {
    member->setComment(std::string("//  ") + _comment, Json::commentBefore);
  }

  return existed;
}

bool MakeDefaultObject(Json::Value& _parent, const char* _name,
                       const char* _comment) {
  // Check if exists first.
  const bool existed = _parent.isMember(_name);
  // Create in any case
  Json::Value* member = &_parent[_name];
  if (!existed) {
    *member = Json::Value(Json::objectValue);
    assert(member->isObject());
  }

  // Pushes comment if there's not one already.
  if (*_comment != 0 && !member->hasComment(Json::commentBefore)) {
    member->setComment(std::string("//  ") + _comment, Json::commentBefore);
  }

  return existed;
}

template <typename _Type>
bool MakeDefault(Json::Value& _parent, const char* _name, _Type _value,
                 const char* _comment) {
  // Check if exists first.
  const bool existed = _parent.isMember(_name);
  // Create in any case
  Json::Value* member = &_parent[_name];
  if (!existed) {
    *member = _value;
    assert(IsCompatibleType(member->type(), ToJsonType<_Type>::type()));
  }

  // Pushes comment if there's not one already.
  if (*_comment != 0 && !member->hasComment(Json::commentAfterOnSameLine)) {
    member->setComment(std::string("//  ") + _comment,
                       Json::commentAfterOnSameLine);
  }

  return existed;
}

bool SanitizeSkeletonJointTypes(Json::Value& _root, bool _all_options) {
  (void)_all_options;
  MakeDefault(_root, "skeleton", true,
              "Uses skeleton nodes as skeleton joints.");
  MakeDefault(_root, "marker", false, "Uses marker nodes as skeleton joints.");
  MakeDefault(_root, "camera", false, "Uses camera nodes as skeleton joints.");
  MakeDefault(_root, "geometry", false,
              "Uses geometry nodes as skeleton joints.");
  MakeDefault(_root, "light", false, "Uses light nodes as skeleton joints.");
  MakeDefault(_root, "null", false, "Uses null nodes as skeleton joints.");
  MakeDefault(_root, "any", false,
              "Uses any node type as skeleton joints, including those listed "
              "above and any other.");

  return true;
}

bool SanitizeSkeletonImport(Json::Value& _root, bool _all_options) {
  (void)_all_options;
  MakeDefault(
      _root, "enable", true,
      "Imports (from source data file) and writes skeleton output file.");
  MakeDefault(_root, "raw", false, "Outputs raw skeleton.");
  MakeDefaultObject(
      _root, "types",
      "Define nodes types that should be considered as skeleton joints.");
  SanitizeSkeletonJointTypes(_root["types"], _all_options);
  return true;
}

bool SanitizeSkeleton(Json::Value& _root, bool _all_options) {
  MakeDefault(_root, "filename", "skeleton.ozz",
              "Specifies skeleton input/output filename. The file will be "
              "outputted if import is true. It will also be used as an input "
              "reference during animations import.");
  MakeDefaultObject(_root, "import", "Define skeleton import settings.");
  SanitizeSkeletonImport(_root["import"], _all_options);

  return true;
}

bool SanitizeOptimizationTolerances(Json::Value& _root) {
  MakeDefault(
      _root, "translation", AnimationOptimizer().translation_tolerance,
      "Translation optimization tolerance, defined as the distance between two "
      "translation values in meters.");

  MakeDefault(_root, "rotation", AnimationOptimizer().rotation_tolerance,
              "Rotation optimization tolerance, ie: the angle between two "
              "rotation values in radian.");

  MakeDefault(_root, "scale", AnimationOptimizer().scale_tolerance,
              "Scale optimization tolerance, ie: the norm of the difference of "
              "two scales.");

  MakeDefault(
      _root, "hierarchical", AnimationOptimizer().hierarchical_tolerance,
      "Hierarchical translation optimization tolerance, ie: the maximum error "
      "(distance) that an optimization on a joint is allowed to generate on "
      "its whole child hierarchy.");

  return true;
}

bool SanitizeTrackImport(Json::Value& _root) {
  MakeDefault(_root, "filename", "*.ozz",
              "Specifies track output filename(s). Use a \'*\' character "
              "to specify part(s) of the filename that should be replaced by "
              "the track (aka \"joint_name-property_name\") name.");
  MakeDefault(_root, "joint_name", "*",
              "Name of the joint that contains the property to import. "
              "Wildcard characters '*' and '?' are supported.");
  MakeDefault(_root, "property_name", "*",
              "Name of the property to import. Wildcard characters '*' and '?' "
              "are supported.");
  MakeDefault(_root, "type", "float1",
              "Type of the property, can be float1 to float4, point and vector "
              "(aka float3 with scene unit and axis conversion).");
  const char* type_name = _root["type"].asCString();
  if (!PropertyTypeConfig::IsValidEnumName(type_name)) {
    ozz::log::Err() << "Invalid value \"" << type_name
                    << "\" for import track type property. Type can be float1 "
                       "to float4, point and vector (aka float3 with scene "
                       "unit and axis conversion)."
                    << std::endl;
    return false;
  }

  MakeDefault(_root, "raw", false, "Outputs raw track.");
  MakeDefault(_root, "optimize", true, "Activates keyframes optimization.");
  MakeDefault(_root, "optimization_tolerance", TrackOptimizer().tolerance,
              "Optimization tolerance");

  return true;
}
/*
bool SanitizeTrackMotion(Json::Value& _root) {
  MakeDefault(_root, "joint_name", "",
              "Name of the joint that contains the property to import. "
              "Wildcard characters '*' and '?' are supported.");
  MakeDefault(_root, "output", "*.ozz",
              "Specifies track output file(s). Use a \'*\' character to "
              "specify part(s) of the filename that should be replaced by the "
              "joint_name.");
  MakeDefault(_root, "optimization_tolerance",
              TrackOptimizer().tolerance,
              "Optimization tolerance");
  return true;
}*/

bool SanitizeTrack(Json::Value& _root, bool _all_options) {
  MakeDefaultArray(_root, "properties", "Properties to import.", !_all_options);
  Json::Value& imports = _root["properties"];
  for (Json::ArrayIndex i = 0; i < imports.size(); ++i) {
    if (!SanitizeTrackImport(imports[i])) {
      return false;
    }
  }
  /*
    MakeDefaultArray(_root, "motions", "Motions tracks to generate.",
                     !_all_options);
    Json::Value& motions = _root["motions"];
    for (Json::ArrayIndex i = 0; i < motions.size(); ++i) {
      if (!SanitizeTrackMotion(motions[i])) {
        return false;
      }
    }*/
  return true;
}

bool SanitizeAnimation(Json::Value& _root, bool _all_options) {
  MakeDefault(_root, "clip", "*",
              "Specifies clip name (take) of the animation to import from the "
              "source file. Wildcard characters \'*\' and \'?\' are supported");

  MakeDefault(_root, "filename", "*.ozz",
              "Specifies animation output filename. Use a \'*\' character to "
              "specify part(s) of the filename that should be replaced by the "
              "clip name.");

  MakeDefault(_root, "raw", false, "Outputs raw animation.");

  MakeDefault(
      _root, "additive", false,
      "Creates a delta animation that can be used for additive blending.");
  MakeDefault(_root, "additive_reference", "animation",
              "Select reference pose to use to build additive/delta animation. "
              "Can be \"animation\" to use the 1st animation keyframe as "
              "reference, or \"skeleton\" to use skeleton bind pose.");

  if (!AdditiveReference::IsValidEnumName(
          _root["additive_reference"].asCString())) {
    ozz::log::Err() << "Invalid additive reference pose \""
                    << _root["additive_reference"].asCString() << "\". \""
                    << "Can be \"animation\" to use the 1st animation keyframe "
                       "as reference, or \"skeleton\" to use skeleton bind "
                       "pose."
                    << std::endl;
    return false;
  }

  MakeDefault(_root, "sampling_rate", 0.f,
              "Selects animation sampling rate in hertz. Set a value <= 0 to "
              "use imported scene default frame rate.");

  MakeDefault(_root, "optimize", true,
              "Activates keyframes reduction optimization.");

  MakeDefaultObject(_root, "optimization_tolerances",
                    "Optimization tolerances.");
  SanitizeOptimizationTolerances(_root["optimization_tolerances"]);

  MakeDefaultArray(_root, "tracks", "Tracks to build.", !_all_options);
  Json::Value& tracks = _root["tracks"];
  for (Json::ArrayIndex i = 0; i < tracks.size(); ++i) {
    if (!SanitizeTrack(tracks[i], _all_options)) {
      return false;
    }
  }

  return true;
}  // namespace

bool SanitizeRoot(Json::Value& _root, bool _all_options) {
  // Skeleton
  MakeDefaultObject(_root, "skeleton", "Skeleton to import");
  SanitizeSkeleton(_root["skeleton"], _all_options);

  // Animations.
  // Forces array creation as it's expected for the defaultconfiguration.
  MakeDefaultArray(_root, "animations", "Animations to import.", false);
  Json::Value& animations = _root["animations"];
  for (Json::ArrayIndex i = 0; i < animations.size(); ++i) {
    if (!SanitizeAnimation(animations[i], _all_options)) {
      return false;
    }
  }

  return true;
}

bool RecursiveCheck(const Json::Value& _root, const Json::Value& _expected,
                    ozz::String::Std _name) {
  if (!IsCompatibleType(_root.type(), _expected.type())) {
    // It's a failure to have a wrong member type.
    ozz::log::Err() << "Invalid type \"" << JsonTypeToString(_root.type())
                    << "\" for json member \"" << _name << "\". \""
                    << JsonTypeToString(_expected.type()) << "\" expected."
                    << std::endl;
    return false;
  }

  if (_root.isArray()) {
    assert(_expected.isArray());
    for (Json::ArrayIndex i = 0; i < _root.size(); ++i) {
      std::ostringstream istr;
      istr << "[" << i << "]";
      if (!RecursiveCheck(_root[i], _expected[0], _name + istr.str().c_str())) {
        return false;
      }
    }
  } else if (_root.isObject()) {
    assert(_expected.isObject());
    for (Json::Value::iterator it = _root.begin(); it != _root.end(); it++) {
      const std::string& name = it.name();
      if (!_expected.isMember(name)) {
        ozz::log::Err() << "Invalid json member \""
                        << _name + "." + name.c_str() << "\"." << std::endl;
        return false;
      }
      const Json::Value& expected_member = _expected[name];
      if (!RecursiveCheck(*it, expected_member, _name + "." + name.c_str())) {
        return false;
      }
    }
  }
  return true;
}

std::string ToString(const Json::Value& _value) {
  // Format configuration
  Json::StreamWriterBuilder builder;
  builder["indentation"] = "  ";
  builder["precision"] = 4;
  return Json::writeString(builder, _value);
}

bool DumpConfig(const char* _path, const Json::Value& _config) {
  if (_path[0] != 0) {
    ozz::log::LogV() << "Opens config file to dump: " << _path << std::endl;
    std::ofstream file(_path);
    if (!file.is_open()) {
      ozz::log::Err() << "Failed to open config file to dump: \"" << _path
                      << "\"" << std::endl;
      return false;
    }
    const std::string& document = ToString(_config);
    file << document;
  }
  return true;
}
}  // namespace

bool CompareName(const char* _a, const char* _b) {
  return std::strcmp(_a, _b) == 0;
}

bool ProcessConfiguration(Json::Value* _config) {
  if (!_config) {
    return false;
  }

  // Use {} as a default config, otherwise take the one specified as argument.
  std::string config_string = "{}";
  // Takes config from program options.
  if (OPTIONS_config.value()[0] != 0) {
    config_string = OPTIONS_config.value();
  } else if (OPTIONS_config_file.value()[0] != 0) {
    ozz::log::LogV() << "Opens config file: \"" << OPTIONS_config_file << "\"."
                     << std::endl;

    std::ifstream file(OPTIONS_config_file.value());
    if (!file.is_open()) {
      ozz::log::Err() << "Failed to open config file: \"" << OPTIONS_config_file
                      << "\"." << std::endl;
      return false;
    }
    config_string.assign(std::istreambuf_iterator<char>(file),
                         std::istreambuf_iterator<char>());
  } else {
    ozz::log::Log() << "No configuration provided, using default configuration."
                    << std::endl;
  }

  Json::Reader json_builder;
  if (!json_builder.parse(config_string, *_config, true)) {
    ozz::log::Err() << "Error while parsing configuration string: "
                    << json_builder.getFormattedErrorMessages() << std::endl;
    return false;
  }

  // Build the reference config to compare it with provided one and detect
  // unexpected members.
  Json::Value ref_config;
  if (!SanitizeRoot(ref_config, true)) {
    assert(false && "Failed to sanitized default configuration.");
  }

  // All format errors are reported within that function
  if (!RecursiveCheck(*_config, ref_config, "root")) {
    return false;
  }

  // Sanitized provided config.
  if (!SanitizeRoot(*_config, false)) {
    return false;
  }

  // Dumps the config to LogV now it's sanitized.
  if (ozz::log::GetLevel() >= ozz::log::kVerbose) {
    const std::string& document = ToString(*_config);
    ozz::log::LogV() << "Sanitized configuration:" << std::endl
                     << document << std::endl;
  }

  // Dumps reference config to file.
  if (!DumpConfig(OPTIONS_config_dump_reference.value(), ref_config)) {
    return false;
  }

  return true;
}
}  // namespace offline
}  // namespace animation
}  // namespace ozz

// Including import2ozz_skel.cc file.

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) 2019 Guillaume Blanc                                         //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//


// Includes internal include file animation/offline/tools/import2ozz_skel.h

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) 2019 Guillaume Blanc                                         //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#ifndef OZZ_ANIMATION_OFFLINE_TOOLS_IMPORT2OZZ_SKEL_H_
#define OZZ_ANIMATION_OFFLINE_TOOLS_IMPORT2OZZ_SKEL_H_

#include "ozz/base/endianness.h"
#include "ozz/base/platform.h"

namespace Json {
class Value;
}

namespace ozz {
namespace animation {
namespace offline {

class OzzImporter;

bool ImportSkeleton(const Json::Value& _config, OzzImporter* _importer,
                    const ozz::Endianness _endianness);

}  // namespace offline
}  // namespace animation
}  // namespace ozz
#endif  // OZZ_ANIMATION_OFFLINE_TOOLS_IMPORT2OZZ_SKEL_H_


#include <cstdlib>
#include <cstring>
#include <iomanip>


// Includes internal include file animation/offline/tools/import2ozz_config.h

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) 2019 Guillaume Blanc                                         //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#ifndef OZZ_ANIMATION_OFFLINE_TOOLS_IMPORT2OZZ_CONFIG_H_
#define OZZ_ANIMATION_OFFLINE_TOOLS_IMPORT2OZZ_CONFIG_H_

#include "ozz/base/platform.h"

#include <json/json-forwards.h>

namespace ozz {
namespace animation {
namespace offline {

// Get the sanitized (all members are set, with the right types) configuration.
bool ProcessConfiguration(Json::Value* _config);

// Internal function used to compare enum names.
bool CompareName(const char* _a, const char* _b);

// Struct allowing inheriting class to provide enum names.
template <typename _Type, typename _Enum>
struct JsonEnum {
  // Struct allowing inheriting class to provide enum names.
  struct EnumNames {
    size_t count;
    const char** names;
  };

  static bool GetEnumFromName(const char* _name, _Enum* _enum) {
    const EnumNames enums = _Type::GetNames();
    for (size_t i = 0; i < enums.count; ++i) {
      if (CompareName(enums.names[i], _name)) {
        *_enum = static_cast<_Enum>(i);
        return true;
      }
    }
    return false;
  }

  static const char* GetEnumName(_Enum _enum) {
    const EnumNames enums = _Type::GetNames();
    assert(static_cast<size_t>(_enum) < enums.count);
    return enums.names[_enum];
  }

  static bool IsValidEnumName(const char* _name) {
    const EnumNames enums = _Type::GetNames();
    bool valid = false;
    for (size_t i = 0; !valid && i < enums.count; ++i) {
      valid = CompareName(enums.names[i], _name);
    }
    return valid;
  }
};

}  // namespace offline
}  // namespace animation
}  // namespace ozz
#endif  // OZZ_ANIMATION_OFFLINE_TOOLS_IMPORT2OZZ_CONFIG_H_


#include "ozz/animation/offline/tools/import2ozz.h"

#include "ozz/animation/offline/raw_skeleton.h"
#include "ozz/animation/offline/skeleton_builder.h"

#include "ozz/animation/runtime/skeleton.h"

#include "ozz/base/containers/map.h"
#include "ozz/base/containers/set.h"

#include "ozz/base/io/archive.h"
#include "ozz/base/io/stream.h"

#include "ozz/base/log.h"

#include <json/json.h>

namespace ozz {
namespace animation {
namespace offline {
namespace {

// Uses a set to detect names uniqueness.
typedef ozz::Set<const char*, ozz::str_less>::Std Names;

bool ValidateJointNamesUniquenessRecurse(
    const RawSkeleton::Joint::Children& _joints, Names* _names) {
  for (size_t i = 0; i < _joints.size(); ++i) {
    const RawSkeleton::Joint& joint = _joints[i];
    const char* name = joint.name.c_str();
    if (!_names->insert(name).second) {
      ozz::log::Err()
          << "Skeleton contains at least one non-unique joint name \"" << name
          << "\", which is not supported." << std::endl;
      return false;
    }
    if (!ValidateJointNamesUniquenessRecurse(_joints[i].children, _names)) {
      return false;
    }
  }
  return true;
}

bool ValidateJointNamesUniqueness(const RawSkeleton& _skeleton) {
  Names joint_names;
  return ValidateJointNamesUniquenessRecurse(_skeleton.roots, &joint_names);
}

void LogHierarchy(const RawSkeleton::Joint::Children& _children,
                  int _depth = 0) {
  const std::streamsize pres = ozz::log::LogV().stream().precision();
  for (size_t i = 0; i < _children.size(); ++i) {
    const RawSkeleton::Joint& joint = _children[i];
    ozz::log::LogV() << std::setw(_depth) << std::setfill('.') << "";
    ozz::log::LogV() << joint.name.c_str() << std::setprecision(4)
                     << " t: " << joint.transform.translation.x << ", "
                     << joint.transform.translation.y << ", "
                     << joint.transform.translation.z
                     << " r: " << joint.transform.rotation.x << ", "
                     << joint.transform.rotation.y << ", "
                     << joint.transform.rotation.z << ", "
                     << joint.transform.rotation.w
                     << " s: " << joint.transform.scale.x << ", "
                     << joint.transform.scale.y << ", "
                     << joint.transform.scale.z << std::endl;

    // Recurse
    LogHierarchy(joint.children, _depth + 1);
  }
  ozz::log::LogV() << std::setprecision(pres);
}
}  // namespace

bool ImportSkeleton(const Json::Value& _config, OzzImporter* _importer,
                    const ozz::Endianness _endianness) {
  const Json::Value& skeleton_config = _config["skeleton"];
  const Json::Value& import_config = skeleton_config["import"];

  // First check that we're actually expecting to import a skeleton.
  if (!import_config["enable"].asBool()) {
    ozz::log::Log() << "Skeleton build disabled, import will be skipped."
                    << std::endl;
    return true;
  }

  // Setup node types import properties.
  const Json::Value& types_config = import_config["types"];
  OzzImporter::NodeType types = {0};
  types.skeleton = types_config["skeleton"].asBool();
  types.marker = types_config["marker"].asBool();
  types.camera = types_config["camera"].asBool();
  types.geometry = types_config["geometry"].asBool();
  types.light = types_config["light"].asBool();
  types.any = types_config["any"].asBool();

  RawSkeleton raw_skeleton;
  if (!_importer->Import(&raw_skeleton, types)) {
    ozz::log::Err() << "Failed to import skeleton." << std::endl;
    return false;
  }

  // Log skeleton hierarchy
  if (ozz::log::GetLevel() == ozz::log::kVerbose) {
    LogHierarchy(raw_skeleton.roots);
  }

  // Non unique joint names are not supported.
  if (!(ValidateJointNamesUniqueness(raw_skeleton))) {
    // Log Err is done by the validation function.
    return false;
  }

  // Needs to be done before opening the output file, so that if it fails then
  // there's no invalid file outputted.
  Skeleton* skeleton = NULL;
  if (!import_config["raw"].asBool()) {
    // Builds runtime skeleton.
    ozz::log::Log() << "Builds runtime skeleton." << std::endl;
    SkeletonBuilder builder;
    skeleton = builder(raw_skeleton);
    if (!skeleton) {
      ozz::log::Err() << "Failed to build runtime skeleton." << std::endl;
      return false;
    }
  }

  // Prepares output stream. File is a RAII so it will close automatically at
  // the end of this scope.
  // Once the file is opened, nothing should fail as it would leave an invalid
  // file on the disk.
  {
    const char* filename = skeleton_config["filename"].asCString();
    ozz::log::Log() << "Opens output file: " << filename << std::endl;
    ozz::io::File file(filename, "wb");
    if (!file.opened()) {
      ozz::log::Err() << "Failed to open output file: \"" << filename << "\"."
                      << std::endl;
      ozz::memory::default_allocator()->Delete(skeleton);
      return false;
    }

    // Initializes output archive.
    ozz::io::OArchive archive(&file, _endianness);

    // Fills output archive with the skeleton.
    if (import_config["raw"].asBool()) {
      ozz::log::Log() << "Outputs RawSkeleton to binary archive." << std::endl;
      archive << raw_skeleton;
    } else {
      ozz::log::Log() << "Outputs Skeleton to binary archive." << std::endl;
      archive << *skeleton;
    }
    ozz::log::Log() << "Skeleton binary archive successfully outputted."
                    << std::endl;
  }

  // Delete local objects.
  ozz::memory::default_allocator()->Delete(skeleton);

  return true;
}
}  // namespace offline
}  // namespace animation
}  // namespace ozz

// Including import2ozz_track.cc file.

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) 2019 Guillaume Blanc                                         //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#include "ozz/animation/offline/tools/import2ozz.h"

#include <cstdlib>
#include <cstring>


// Includes internal include file animation/offline/tools/import2ozz_config.h

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) 2019 Guillaume Blanc                                         //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#ifndef OZZ_ANIMATION_OFFLINE_TOOLS_IMPORT2OZZ_CONFIG_H_
#define OZZ_ANIMATION_OFFLINE_TOOLS_IMPORT2OZZ_CONFIG_H_

#include "ozz/base/platform.h"

#include <json/json-forwards.h>

namespace ozz {
namespace animation {
namespace offline {

// Get the sanitized (all members are set, with the right types) configuration.
bool ProcessConfiguration(Json::Value* _config);

// Internal function used to compare enum names.
bool CompareName(const char* _a, const char* _b);

// Struct allowing inheriting class to provide enum names.
template <typename _Type, typename _Enum>
struct JsonEnum {
  // Struct allowing inheriting class to provide enum names.
  struct EnumNames {
    size_t count;
    const char** names;
  };

  static bool GetEnumFromName(const char* _name, _Enum* _enum) {
    const EnumNames enums = _Type::GetNames();
    for (size_t i = 0; i < enums.count; ++i) {
      if (CompareName(enums.names[i], _name)) {
        *_enum = static_cast<_Enum>(i);
        return true;
      }
    }
    return false;
  }

  static const char* GetEnumName(_Enum _enum) {
    const EnumNames enums = _Type::GetNames();
    assert(static_cast<size_t>(_enum) < enums.count);
    return enums.names[_enum];
  }

  static bool IsValidEnumName(const char* _name) {
    const EnumNames enums = _Type::GetNames();
    bool valid = false;
    for (size_t i = 0; !valid && i < enums.count; ++i) {
      valid = CompareName(enums.names[i], _name);
    }
    return valid;
  }
};

}  // namespace offline
}  // namespace animation
}  // namespace ozz
#endif  // OZZ_ANIMATION_OFFLINE_TOOLS_IMPORT2OZZ_CONFIG_H_


// Includes internal include file animation/offline/tools/import2ozz_track.h

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) 2019 Guillaume Blanc                                         //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#ifndef OZZ_ANIMATION_OFFLINE_TOOLS_IMPORT2OZZ_TRACK_H_
#define OZZ_ANIMATION_OFFLINE_TOOLS_IMPORT2OZZ_TRACK_H_

#include "ozz/base/endianness.h"
#include "ozz/base/platform.h"


// Includes internal include file animation/offline/tools/import2ozz_config.h

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) 2019 Guillaume Blanc                                         //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#ifndef OZZ_ANIMATION_OFFLINE_TOOLS_IMPORT2OZZ_CONFIG_H_
#define OZZ_ANIMATION_OFFLINE_TOOLS_IMPORT2OZZ_CONFIG_H_

#include "ozz/base/platform.h"

#include <json/json-forwards.h>

namespace ozz {
namespace animation {
namespace offline {

// Get the sanitized (all members are set, with the right types) configuration.
bool ProcessConfiguration(Json::Value* _config);

// Internal function used to compare enum names.
bool CompareName(const char* _a, const char* _b);

// Struct allowing inheriting class to provide enum names.
template <typename _Type, typename _Enum>
struct JsonEnum {
  // Struct allowing inheriting class to provide enum names.
  struct EnumNames {
    size_t count;
    const char** names;
  };

  static bool GetEnumFromName(const char* _name, _Enum* _enum) {
    const EnumNames enums = _Type::GetNames();
    for (size_t i = 0; i < enums.count; ++i) {
      if (CompareName(enums.names[i], _name)) {
        *_enum = static_cast<_Enum>(i);
        return true;
      }
    }
    return false;
  }

  static const char* GetEnumName(_Enum _enum) {
    const EnumNames enums = _Type::GetNames();
    assert(static_cast<size_t>(_enum) < enums.count);
    return enums.names[_enum];
  }

  static bool IsValidEnumName(const char* _name) {
    const EnumNames enums = _Type::GetNames();
    bool valid = false;
    for (size_t i = 0; !valid && i < enums.count; ++i) {
      valid = CompareName(enums.names[i], _name);
    }
    return valid;
  }
};

}  // namespace offline
}  // namespace animation
}  // namespace ozz
#endif  // OZZ_ANIMATION_OFFLINE_TOOLS_IMPORT2OZZ_CONFIG_H_

#include "ozz/animation/offline/tools/import2ozz.h"

namespace Json {
class Value;
}

namespace ozz {
namespace animation {
class Skeleton;
namespace offline {

class OzzImporter;
bool ProcessTracks(OzzImporter& _importer, const char* _animation_name,
                   const Skeleton& _skeleton, const Json::Value& _config,
                   const ozz::Endianness _endianness);

// Property type enum to config string conversions.
struct PropertyTypeConfig
    : JsonEnum<PropertyTypeConfig, OzzImporter::NodeProperty::Type> {
  static EnumNames GetNames();
};
}  // namespace offline
}  // namespace animation
}  // namespace ozz
#endif  // OZZ_ANIMATION_OFFLINE_TOOLS_IMPORT2OZZ_TRACK_H_


#include "ozz/animation/offline/raw_track.h"
#include "ozz/animation/offline/track_builder.h"
#include "ozz/animation/offline/track_optimizer.h"

#include "ozz/animation/runtime/skeleton.h"
#include "ozz/animation/runtime/track.h"

#include "ozz/base/io/archive.h"
#include "ozz/base/io/stream.h"

#include "ozz/base/log.h"

#include "ozz/options/options.h"

#include <json/json.h>

namespace ozz {
namespace animation {
namespace offline {
namespace {

bool IsCompatiblePropertyType(OzzImporter::NodeProperty::Type _src,
                              OzzImporter::NodeProperty::Type _dest) {
  if (_src == _dest) {
    return true;
  }
  switch (_src) {
    case OzzImporter::NodeProperty::kFloat3:
      return _dest == OzzImporter::NodeProperty::kPoint ||
             _dest == OzzImporter::NodeProperty::kVector;
    case OzzImporter::NodeProperty::kPoint:
    case OzzImporter::NodeProperty::kVector:
      return _dest == OzzImporter::NodeProperty::kFloat3;
    default:
      return false;
  }
}

template <typename _RawTrack>
struct RawTrackToTrack;

template <>
struct RawTrackToTrack<RawFloatTrack> {
  typedef FloatTrack Track;
};
template <>
struct RawTrackToTrack<RawFloat2Track> {
  typedef Float2Track Track;
};
template <>
struct RawTrackToTrack<RawFloat3Track> {
  typedef Float3Track Track;
};
template <>
struct RawTrackToTrack<RawFloat4Track> {
  typedef Float4Track Track;
};

template <typename _RawTrack>
bool Export(OzzImporter& _importer, const _RawTrack& _raw_track,
            const Json::Value& _config, const ozz::Endianness _endianness) {
  // Raw track to build and output.
  _RawTrack raw_track;

  // Optimizes track if option is enabled.
  if (_config["optimize"].asBool()) {
    ozz::log::LogV() << "Optimizing track." << std::endl;
    TrackOptimizer optimizer;
    optimizer.tolerance = _config["optimization_tolerance"].asFloat();
    _RawTrack raw_optimized_track;
    if (!optimizer(_raw_track, &raw_optimized_track)) {
      ozz::log::Err() << "Failed to optimize track." << std::endl;
      return false;
    }

    // Displays optimization statistics.
    // DisplaysOptimizationstatistics(raw_animation, raw_optimized_animation);

    // Brings data back to the raw track.
    raw_track = raw_optimized_track;
  }

  // Builds runtime track.
  typename RawTrackToTrack<_RawTrack>::Track* track = NULL;
  if (!_config["raw"].asBool()) {
    ozz::log::LogV() << "Builds runtime track." << std::endl;
    TrackBuilder builder;
    track = builder(raw_track);
    if (!track) {
      ozz::log::Err() << "Failed to build runtime track." << std::endl;
      return false;
    }
  }

  {
    // Prepares output stream. Once the file is opened, nothing should fail as
    // it would leave an invalid file on the disk.

    // Builds output filename.
    const ozz::String::Std filename = _importer.BuildFilename(
        _config["filename"].asCString(), _raw_track.name.c_str());

    ozz::log::LogV() << "Opens output file: " << filename << std::endl;
    ozz::io::File file(filename.c_str(), "wb");
    if (!file.opened()) {
      ozz::log::Err() << "Failed to open output file: " << filename
                      << std::endl;
      ozz::memory::default_allocator()->Delete(track);
      return false;
    }

    // Initializes output archive.
    ozz::io::OArchive archive(&file, _endianness);

    // Fills output archive with the track.
    if (_config["raw"].asBool()) {
      ozz::log::LogV() << "Outputs RawTrack to binary archive." << std::endl;
      archive << raw_track;
    } else {
      ozz::log::LogV() << "Outputs Track to binary archive." << std::endl;
      archive << *track;
    }
  }

  ozz::log::LogV() << "Track binary archive successfully outputted."
                   << std::endl;

  // Delete local objects.
  ozz::memory::default_allocator()->Delete(track);

  return true;
}

template <typename _TrackType>
bool ProcessImportTrackType(
    OzzImporter& _importer, const char* _animation_name,
    const char* _joint_name, const OzzImporter::NodeProperty& _property,
    const OzzImporter::NodeProperty::Type _expected_type,
    const Json::Value& _import_config, const ozz::Endianness _endianness) {
  bool success = true;

  _TrackType track;
  success &=
      _importer.Import(_animation_name, _joint_name, _property.name.c_str(),
                       _expected_type, 0, &track);

  if (success) {
    // Give the track a name
    track.name = _joint_name;
    track.name += '-';
    track.name += _property.name.c_str();

    success &= Export(_importer, track, _import_config, _endianness);
  } else {
    ozz::log::Err() << "Failed to import track \"" << _joint_name << ":"
                    << _property.name << "\"" << std::endl;
  }

  return success;
}

bool ProcessImportTrack(OzzImporter& _importer, const char* _animation_name,
                        const Skeleton& _skeleton,
                        const Json::Value& _import_config,
                        const ozz::Endianness _endianness) {
  // Early out if no name is specified
  const char* joint_name_match = _import_config["joint_name"].asCString();
  const char* ppt_name_match = _import_config["property_name"].asCString();

  // Process every joint that matches.
  bool success = true;
  bool joint_found = false;
  for (int s = 0; success && s < _skeleton.num_joints(); ++s) {
    const char* joint_name = _skeleton.joint_names()[s];
    if (!strmatch(joint_name, joint_name_match)) {
      continue;
    }
    joint_found = true;

    // Node found, need to find matching properties now.
    bool ppt_found = false;
    const OzzImporter::NodeProperties properties =
        _importer.GetNodeProperties(joint_name);
    for (size_t p = 0; p < properties.size(); ++p) {
      const OzzImporter::NodeProperty& property = properties[p];
      // Checks property name matches
      const char* property_name = property.name.c_str();
      ozz::log::LogV() << "Inspecting property " << joint_name << ":"
                       << property_name << "\"." << std::endl;
      if (!strmatch(property_name, ppt_name_match)) {
        continue;
      }
      // Checks property type matches
      const char* expected_type_name = _import_config["type"].asCString();
      OzzImporter::NodeProperty::Type expected_type =
          OzzImporter::NodeProperty::kFloat1;
      bool valid_type = PropertyTypeConfig::GetEnumFromName(expected_type_name,
                                                            &expected_type);
      (void)valid_type;
      assert(valid_type &&
             "Type should have been checked during config validation");
      bool compatible_type =
          IsCompatiblePropertyType(property.type, expected_type);

      if (!compatible_type) {
        ozz::log::Log() << "Incompatible type \"" << expected_type_name
                        << "\" for matching property \"" << joint_name << ":"
                        << property_name << "\" of type \""
                        << PropertyTypeConfig::GetEnumName(property.type)
                        << "\"." << std::endl;
        continue;
      }

      ozz::log::LogV() << "Found matching property \"" << joint_name << ":"
                       << property_name << "\" of type \""
                       << PropertyTypeConfig::GetEnumName(property.type)
                       << "\"." << std::endl;

      // A property has been found.
      ppt_found = true;

      // Import property depending on its type.
      switch (property.type) {
        case OzzImporter::NodeProperty::kFloat1: {
          success &= ProcessImportTrackType<RawFloatTrack>(
              _importer, _animation_name, joint_name, property, expected_type,
              _import_config, _endianness);
          break;
        }
        case OzzImporter::NodeProperty::kFloat2: {
          success &= ProcessImportTrackType<RawFloat2Track>(
              _importer, _animation_name, joint_name, property, expected_type,
              _import_config, _endianness);
          break;
        }
        case OzzImporter::NodeProperty::kFloat3:
        case OzzImporter::NodeProperty::kPoint:
        case OzzImporter::NodeProperty::kVector: {
          success &= ProcessImportTrackType<RawFloat3Track>(
              _importer, _animation_name, joint_name, property, expected_type,
              _import_config, _endianness);
          break;
        }
        case OzzImporter::NodeProperty::kFloat4: {
          success &= ProcessImportTrackType<RawFloat4Track>(
              _importer, _animation_name, joint_name, property, expected_type,
              _import_config, _endianness);
          break;
        }
        default: {
          assert(false && "Unknown property type.");
          success = false;
          break;
        }
      }
    }

    if (!ppt_found) {
      ozz::log::Log() << "No property found for track import definition \""
                      << joint_name_match << ":" << ppt_name_match << "\"."
                      << std::endl;
    }
  }

  if (!joint_found) {
    ozz::log::Log() << "No joint found for track import definition \""
                    << joint_name_match << "\"." << std::endl;
  }

  return success;
}

/*
bool ProcessMotionTrack(OzzImporter& _importer,
                        const char* _animation_name, const Skeleton&
_skeleton, const Json::Value& _motion) { return true;
}*/
}  // namespace

bool ProcessTracks(OzzImporter& _importer, const char* _animation_name,
                   const Skeleton& _skeleton, const Json::Value& _config,
                   const ozz::Endianness _endianness) {
  bool success = true;

  const Json::Value& imports = _config["properties"];
  for (Json::ArrayIndex i = 0; success && i < imports.size(); ++i) {
    success &= ProcessImportTrack(_importer, _animation_name, _skeleton,
                                  imports[i], _endianness);
  }

  /*
    const Json::Value& motions = _config["motions"];
    for (Json::ArrayIndex i = 0; success && i < motions.size(); ++i) {
      success &=
          ProcessMotionTrack(_importer, _animation_name, _skeleton,
    motions[i]);
    }*/

  return success;
}

PropertyTypeConfig::EnumNames PropertyTypeConfig::GetNames() {
  static const char* kNames[] = {"float1", "float2", "float3",
                                 "float4", "point",  "vector"};
  const EnumNames enum_names = {OZZ_ARRAY_SIZE(kNames), kNames};
  return enum_names;
}
}  // namespace offline
}  // namespace animation
}  // namespace ozz

